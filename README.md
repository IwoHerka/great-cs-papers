## Opinionated collection of great papers on functional programming and software-engineering

What follows is a compilation of papers and articles which were very
influential in the development of _my_ understanding of computer science
and programming. In another words, this is not a hall of fame; I list 
them because I believe they provide immensely useful information for 
aspiring programmers; programmers to whom this list may be recommended.
For this reason, positions included here may not be necessarily "great"
by any standard other than mine. (Although there is an obvious overlap -
some recommendations may even verge on being a cliché.)

<br>

### [Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I - J. McCarthy - 1960](https://github.com/IwoHerka/great-cs-papers/blob/master/Recursive_Functions_of_Symbolic_Expressions_and_Their_Computation_by_Machine_McCarthy.pdf)

_Abstract_: In this article, we first describe a formalism for defining
functions recursively. We believe this formalism has advantages both as
a programming language and as a vehicle for developing a theory of
computation. Next, we describe S-expressions and S-functions, give some
examples, and then describe the universal S-function apply which plays
the theoretical role of a universal Turing machine and the practical
role of an interpreter. Then we describe the representation of S-expressions
in the memory of the IBM 704 by list structures similar to those used by
Newell, Shaw and Simon [2], and the representation of S-functions by
program. Then we mention the main features of the LISP programming system
for the IBM 704. Next comes another way of describing computations with
symbolic expressions, and finally we give a recursive function
interpretation of flow charts.

### [Go To Considered Harmful - E. Dijkstra - 1968](https://github.com/IwoHerka/great-cs-papers/blob/master/Go_To_Statement_Considered_Harmful_E_Dijkstra.pdf)

_Abstract_: For a number of years I have been familiar with the observation
that the quality of programmers is a decreasing function of the density of
go to statements in the programs they produce. More recently I discovered
why the use of the go to statement has such disastrous effects, and I became
convinced that the go to statement should be abolished from all "higher level"
programming languages (i.e. everything except, perhaps, plain machine code).
At that time I did not attach too much importance to this discovery; I now
submit my considerations for publication because in very recent discussions
in which the subject turned up, I have been urged to do so.

### [An Axiomatic Basis for Computer Programming - C. A. R. Hoare - 1969](https://github.com/IwoHerka/great-cs-papers/blob/master/An_Axiomatic_Basis_for_Computer_Programming_C_A_R_Hoare.pdf)

_Abstract_: In this paper an attempt is made to explore the logical 
foundations of computer programming by use of techniques which were first 
applied in the study of geometry and have later been extended to other 
branches of mathematics. This involves the elucidation of sets of axioms
and rules of inference which can be used in proofs of the properties of 
computer programs. Examples are given of such axioms and rules, and a formal
proof of a simple theorem is displayed. Finally, it is argued that important
advantage, both theoretical and practical, may follow from a pursuance of
these topics.

### [No Silver Bullet - Essence and Accidents of Software Engineering - F. P. Brooks Jr. - 1987](https://github.com/IwoHerka/great-cs-papers/blob/master/No_Silver_Bullet_Essence_and_Accidents_of_Software_Engineering_F_P_Brooks_Jr.pdf)

_Abstract_: 
Of all the monsters that fill the nightmares of our folklore, none terrify
more than werewolves, because they transform unexpectedly from the familiar
into horrors. For these, one seeks bullets of silver that can magically lay
them to rest. The familiar software project, at least as seen by the
nontechnical manager, has something of this character; it is usually innocent
and straightforward, but is capable of becoming a monster of missed schedules,
blown budgets, and flawed products. So we hear desperate cries for a silver
bullet--something to make software costs drop as rapidly as computer hardware
costs do.

### [Why Functional Programming Matters - J. Hughes - 1989/1990](https://github.com/IwoHerka/great-cs-papers/blob/master/Why_Functional_Programming_Matters_J_Hughes.pdf)

_Abstract_: As software becomes more and more complex, it is more and more
important to structure it well. Well-structured software is easy to write
and to debug, and provides a collection of modules that can be reused
to reduce future programming costs. In this paper we show that two features
of functional languages in particular, higher-order functions and lazy
evaluation, can contribute significantly to modularity. As examples, we
manipulate lists and trees, program several numerical algorithms, and implement
the alpha-beta heuristic (an algorithm from Artificial Intelligence
used in game-playing programs). We conclude that since modularity is the
key to successful programming, functional programming offers important
advantages for software development.

### [The Roots of Lisp](https://github.com/IwoHerka/great-cs-papers/blob/master/The_Roots_of_Lisp.pdf)

_Abstract_: In 1960, John McCarthy published a remarkable paper in which he
did for programming something like what Euclid did for geometry.1 He showed how, given
a handful of simple operators and a notation for functions, you can build a
whole programming language. He called this language Lisp, for “List Processing,”
because one of his key ideas was to use a simple data structure called a
list for both code and data.

### [Out of the Tar Pit - B. Moseley, P. Marks - 2006](https://github.com/IwoHerka/great-cs-papers/blob/master/Out_of_the_Tar_Pit_B_Moseley_P_Marks.pdf)

_Abstract_: Complexity is the single major difficulty in the successful development
of large-scale software systems. Following Brooks we distinguish
accidental from essential difficulty, but disagree with his premise that
most complexity remaining in contemporary systems is essential. We
identify common causes of complexity and discuss general approaches
which can be taken to eliminate them where they are accidental in
nature. To make things more concrete we then give an outline for
a potential complexity-minimizing approach based on functional programming
and Codd’s relational model of data.
